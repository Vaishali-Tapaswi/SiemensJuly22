Lab 5 -  by var x *int - x is pointing to memory not actual data,
                        x = &i will point x to address of i, so if i gets changed later, it will be same fo *x
            package main

            import (
                        "fmt"
            )
            func main(){
                        i := 10
                        fmt.Println(i)
                        fmt.Println(&i)
                        var x *int
                        x = &i
                        i = 400
                        fmt.Println(x)
                        fmt.Println(*x)

            }
Lab 4 -  by x = i, we are creating a new variable with same value, so even if original value(i) gets changed, it will not be reflected
            package main

            import (
                        "fmt"
            )
            func main(){
                        i := 10
                        fmt.Println(i)
                        fmt.Println(&i)
                        x := i
                        i = 1000
                        fmt.Println(x)
                        fmt.Println(&x)
            }

Lab 3 -  Write defer for single line at a time and see impact (Line number 10, 13, 18, 26)
            and then with combinations
            Observe  - impact of defer for sequence of execution, when the function parameters are getting evaluated and
                        what will be use of the same
            package main

            import (
                  "fmt"
            )

            func main(){

                  fmt.Println("Hello ")
                  fmt.Println("1")
                  fmt.Println("invoking test with i = 10")
                  test(10)
                  fmt.Println("2")
                  str := "One"
                  test1(str)
                  str = "Two"
                  test1(str)
                  fmt.Println("3")
                  fmt.Println("4")

            }

            func test(  i int){
                  fmt.Println("\tline1 of test ")
                  fmt.Println("\tin test " , i)
                  fmt.Println("\tline3 of test ")
            }


            func test1( str string){
                  fmt.Println("\tin test1 ", str)
            }


package main

            import (
                  "fmt"
            )

            func main(){

                  fmt.Println("Hello ")
                  fmt.Println("1")
                  fmt.Println("invoking test with i = 10")
                  test(10)
                  fmt.Println("2")
                  str := "One"
                  test1(str)
                  str = "Two"
                  test1(str)
                  fmt.Println("3")
                  fmt.Println("4")

            }

            func test(  i int){
                  fmt.Println("\tline1 of test ")
                  fmt.Println("\tin test " , i)
                  fmt.Println("\tline3 of test ")
            }


            func test1( str string){
                  fmt.Println("\tin test1 ", str)
            }


Lab2 - Replace sqr and cube functions with go library math.power
Lab1 - Default variable reference(method), multiple returns, named returnd
      package main

      import (
        "fmt"
      )
      var x int =100
      // x1:=300 - not allowed outside function body
      func main(){
        //var name type = expression
        var x int =3000
        fmt.Println("x = ", x)
        sqr, cube:=test(10)
        fmt.Println("test Sqr = ", sqr , " Cube = " , cube)
        sqr, cube=test1(5)
        fmt.Println("test1 Sqr = ", sqr , " Cube = " , cube)
      }

      func test( no1 int)(int, int){
        return no1*no1, no1*no1*no1
      }

      func test1( no1 int)(sq,cu int){
        sq=no1*no1
        cu=no1*no1*no1
        return
      }
