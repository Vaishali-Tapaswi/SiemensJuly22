Lab 8 - Write a struct Emp - empno int, ename string, salary int
        Write Print method to show all the details
        Write incr method accepting int arg(pern) and change salary by that %age
        
Lab 7 - Receiver Method
        package main
        import (
                "fmt"
        )

        type Point struct {
                x int
                y int
        }

        func main(){
                p1 := Point{20,50}
                fmt.Println("Original Point " , p1)
                p1.shift( 1,3)
                fmt.Println("After Shift " , p1)


        }

        func (pint *Point) shift(x, y int)  {
            pint.x += x
                pint.y+=y
                fmt.Println("In shift ", pint)
        }


Lab 6 - Write a method called shift(point Point, x,y as int) where point should be shifted (add x to x and y co-ordinates)
        Write a method add accepting two points and create third point (x+x1, y+y1)
          package main

          import (
            "fmt"
          )
          type Point struct {
            x int
            y int
          }

          func main(){
          //	p1 := Point{1,5}
          //	p1 := Point{y : 10}
            p1 := Point{}
            fmt.Println(p1)

          }



Lab 5 -  by var x *int - x is pointing to memory not actual data,
                        x = &i will point x to address of i, so if i gets changed later, it will be same fo *x
            package main

            import (
                        "fmt"
            )
            func main(){
                        i := 10
                        fmt.Println(i)
                        fmt.Println(&i)
                        var x *int
                        x = &i
                        i = 400
                        fmt.Println(x)
                        fmt.Println(*x)

            }
Lab 4 -  by x = i, we are creating a new variable with same value, so even if original value(i) gets changed, it will not be reflected
            package main

            import (
                        "fmt"
            )
            func main(){
                        i := 10
                        fmt.Println(i)
                        fmt.Println(&i)
                        x := i
                        i = 1000
                        fmt.Println(x)
                        fmt.Println(&x)
            }

Lab 3 -  Write defer for single line at a time and see impact (Line number 10, 13, 18, 26)
            and then with combinations
            Observe  - impact of defer for sequence of execution, when the function parameters are getting evaluated and
                        what will be use of the same
            package main

            import (
                  "fmt"
            )

            func main(){

                  fmt.Println("Hello ")
                  fmt.Println("1")
                  fmt.Println("invoking test with i = 10")
                  test(10)
                  fmt.Println("2")
                  str := "One"
                  test1(str)
                  str = "Two"
                  test1(str)
                  fmt.Println("3")
                  fmt.Println("4")

            }

            func test(  i int){
                  fmt.Println("\tline1 of test ")
                  fmt.Println("\tin test " , i)
                  fmt.Println("\tline3 of test ")
            }


            func test1( str string){
                  fmt.Println("\tin test1 ", str)
            }


package main

            import (
                  "fmt"
            )

            func main(){

                  fmt.Println("Hello ")
                  fmt.Println("1")
                  fmt.Println("invoking test with i = 10")
                  test(10)
                  fmt.Println("2")
                  str := "One"
                  test1(str)
                  str = "Two"
                  test1(str)
                  fmt.Println("3")
                  fmt.Println("4")

            }

            func test(  i int){
                  fmt.Println("\tline1 of test ")
                  fmt.Println("\tin test " , i)
                  fmt.Println("\tline3 of test ")
            }


            func test1( str string){
                  fmt.Println("\tin test1 ", str)
            }


Lab2 - Replace sqr and cube functions with go library math.power
Lab1 - Default variable reference(method), multiple returns, named returnd
      package main

      import (
        "fmt"
      )
      var x int =100
      // x1:=300 - not allowed outside function body
      func main(){
        //var name type = expression
        var x int =3000
        fmt.Println("x = ", x)
        sqr, cube:=test(10)
        fmt.Println("test Sqr = ", sqr , " Cube = " , cube)
        sqr, cube=test1(5)
        fmt.Println("test1 Sqr = ", sqr , " Cube = " , cube)
      }

      func test( no1 int)(int, int){
        return no1*no1, no1*no1*no1
      }

      func test1( no1 int)(sq,cu int){
        sq=no1*no1
        cu=no1*no1*no1
        return
      }
